// "NanoBanana" es el alias interno para el modelo de im√°genes de Gemini 2.5 Flash.
// Integramos directamente con la API oficial de Gemini para generaci√≥n/edici√≥n de imagen
// usando el modelo "gemini-2.5-flash-image-preview" (configurable por env).

export type NanoStep = "m4" | "m8" | "m12";

async function fetchImageAsInlineData(url: string): Promise<{ mimeType: string; data: string }> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Failed fetching base image: ${res.status}`);
  const mimeType = res.headers.get("content-type") || "image/jpeg";
  const arrayBuffer = await res.arrayBuffer();
  const data = Buffer.from(arrayBuffer).toString("base64");
  return { mimeType, data };
}

export async function generateTransformedImage(params: {
  imageUrl: string; // Signed URL to original in Firebase Storage
  profile: {
    age: number;
    sex: "male" | "female" | "other";
    heightCm: number;
    weightKg: number;
    level: "novato" | "intermedio" | "avanzado";
    goal: "definicion" | "masa" | "mixto";
    weeklyTime: number;
    notes?: string;
  };
  step: NanoStep; // which month projection
  aiPrompt?: string; // The specific visual prompt generated by Gemini
}): Promise<{ buffer: Buffer; contentType: string }> {
  const apiKey = process.env.GEMINI_API_KEY;
  const model = process.env.GEMINI_IMAGE_MODEL || "gemini-2.5-flash-image-preview";
  if (!apiKey) throw new Error("Missing GEMINI_API_KEY for NanoBanana (Gemini 2.5 Flash Image)");

  const { mimeType, data } = await fetchImageAsInlineData(params.imageUrl);

  // Prompt enfocado a cambios realistas y consistentes con NGX
  const goalMap = {
    definicion: "shredded, extremely low body fat, visible abs, vascularity, defined jawline, lean face",
    masa: "massive muscle hypertrophy, bodybuilder physique, broad shoulders, thick chest, powerful arms, thick neck",
    mixto: "athletic superhero physique, perfect proportions, lean and muscular, functional strength, wide shoulders"
  };
  const aggressiveBase = goalMap[params.profile.goal] || "athletic fitness transformation";

  // Progression multiplier based on step (m4=40%, m8=70%, m12=100%)
  const progressionMap: Record<NanoStep, { percent: number; phase: string; intensity: string }> = {
    m4: { percent: 40, phase: "FOUNDATION PHASE", intensity: "early visible changes, initial muscle definition, improved posture" },
    m8: { percent: 70, phase: "TRANSFORMATION PHASE", intensity: "significant muscle gains, clear definition, athletic build emerging" },
    m12: { percent: 100, phase: "PEAK FORM", intensity: "maximum transformation, elite athlete physique, competition-ready" }
  };
  const progression = progressionMap[params.step];

  // STRATEGY: Premium Cinematic (Nike/Adidas Commercial Style) WITH PROGRESSION
  const prompt = `GENERATE A NEW IMAGE based on this person.

  TRANSFORMATION STAGE: ${progression.phase} (${progression.percent}% of journey)
  TRANSFORMATION TARGET: ${aggressiveBase}
  CURRENT PROGRESS: ${progression.intensity}

  CRITICAL INSTRUCTION:
  Create a MASTERPIECE of fitness photography showing ${progression.percent}% progress toward the goal.
  Style: "NIKE ADVERTISEMENT", "CINEMATIC LIGHTING", "HIGH CONTRAST", "PROFESSIONAL COLOR GRADING".

  1. FACE: Keep the identity perfectly.
  2. BODY: Show ${progression.percent}% transformation toward ${aggressiveBase}. ${params.step === "m4" ? "Subtle but noticeable changes." : params.step === "m8" ? "Clear visible transformation." : "DRAMATIC FINAL TRANSFORMATION."}
  3. ATMOSPHERE: Intense, gritty but clean, dramatic shadows, volumetric lighting (God rays).
  4. CLOTHING: Premium athletic wear (Under Armour/Nike style) or shirtless to show definition.
  5. DETAILS: Sweat, skin texture, ${params.step === "m12" ? "veins, striations, " : ""}determined expression.

  If the output looks like a snapshot or selfie, YOU HAVE FAILED.
  MAKE IT LOOK LIKE A BILLBOARD CAMPAIGN.`;

  console.log("üçå NanoBanana Prompt:", prompt);

  const endpoint = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

  const body = {
    contents: [
      {
        role: "user",
        parts: [
          { text: prompt },
          { inlineData: { mimeType, data } }, // imagen base para image-to-image
        ],
      },
    ],
    generationConfig: {
      // responseMimeType removed as it causes INVALID_ARGUMENT
    },
    safetySettings: [
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
    ],
  } as const;

  console.log("üçå Sending request to Gemini...");
  const resp = await fetch(endpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });

  if (!resp.ok) {
    const errTxt = await resp.text().catch(() => "");
    throw new Error(`Gemini image API error ${resp.status}: ${errTxt}`);
  }

  const json = await resp.json();
  // Navegamos la estructura para extraer inlineData
  // Esperado: candidates[0].content.parts[0].inlineData.{data,mimeType}
  const candidates = json?.candidates || [];
  const parts = candidates[0]?.content?.parts || candidates[0]?.content || [];
  let inlineData = null as null | { data: string; mimeType?: string };

  for (const p of parts) {
    if (p?.inlineData?.data) { inlineData = p.inlineData; break; }
  }

  if (!inlineData?.data) {
    throw new Error("Gemini image API: no inline image data found in response");
  }

  const outMime = inlineData.mimeType || "image/jpeg";
  const buffer = Buffer.from(inlineData.data, "base64");
  return { buffer, contentType: outMime };
}
